<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [OSI 协议七层模型与 TCP/IP 协议五层模型](#osi-%E5%8D%8F%E8%AE%AE%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8E-tcpip-%E5%8D%8F%E8%AE%AE%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B)
- [应用层的协议哪些是基于 TCP 协议的，哪些是基于 UDP 协议的](#%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%93%AA%E4%BA%9B%E6%98%AF%E5%9F%BA%E4%BA%8E-tcp-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%93%AA%E4%BA%9B%E6%98%AF%E5%9F%BA%E4%BA%8E-udp-%E5%8D%8F%E8%AE%AE%E7%9A%84)
  - [基于 TCP 协议的](#%E5%9F%BA%E4%BA%8E-tcp-%E5%8D%8F%E8%AE%AE%E7%9A%84)
  - [基于 UDP 协议的](#%E5%9F%BA%E4%BA%8E-udp-%E5%8D%8F%E8%AE%AE%E7%9A%84)
  - [基于 TCP 和 UDP 协议的](#%E5%9F%BA%E4%BA%8E-tcp-%E5%92%8C-udp-%E5%8D%8F%E8%AE%AE%E7%9A%84)
- [TCP 和 UDP 之间的区别](#tcp-%E5%92%8C-udp-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB)
- [TCP 的三次握手](#tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)
- [TCP 的四次挥手](#tcp-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
- [HTTP 状态码](#http-%E7%8A%B6%E6%80%81%E7%A0%81)
- [HTTP1.0 和 HTTP1.1 和 HTTP2.0 的区别](#http10-%E5%92%8C-http11-%E5%92%8C-http20-%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [HTTP1.0 和 HTTP1.1](#http10-%E5%92%8C-http11)
  - [http2.0 与 http1.X 区别](#http20-%E4%B8%8E-http1x-%E5%8C%BA%E5%88%AB)
- [HTTP 与 HTTPS 的区别](#http-%E4%B8%8E-https-%E7%9A%84%E5%8C%BA%E5%88%AB)
- [对称加密和非对称加密的区别](#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%8C%BA%E5%88%AB)
- [Https 的单向认证通信过程](#https-%E7%9A%84%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B)
- [WebSocket 协议](#websocket-%E5%8D%8F%E8%AE%AE)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## OSI 协议七层模型与 TCP/IP 协议五层模型

- OSI（Open System Interconnect）开放式系统互连

  ```txt
  应用层
  表示层
  会话层
  传输层
  网络层
  数据链路层
  物理层
  ```

- TCP/IP 五层模型

  ```txt
  应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet
  传输层：TCP，UDP
  网络层：IP，ICMP，RIP，OSPF，BGP，IGMP
  数据链路层：SLIP，CSLIP，PPP，ARP，RARP，MTU
  物理层
  ```

  ![7层协议](../images/browser/7层协议.gif)

## 应用层的协议哪些是基于 TCP 协议的，哪些是基于 UDP 协议的

### 基于 TCP 协议的

- FTP（文件传输协议）：定义了文件传输协议，使用 21 端口。
- TELNET（远程登陆协议）：一种用于远程登陆的端口，使用 23 端口，用户可以以自己的身份远程连接到计算机上，可提供基于 DOS 模式下的通信服务。
- SMTP（简单邮件传输协议）：邮件传送协议，用于发送邮件。服务器开放的是 25 号端口。
- POP3（邮件读取协议）：它是和 SMTP 对应，POP3 用于接收邮件。POP3 协议所用的是 110 端口。
- HTTP（超文本传输协议）：是从 Web 服务器传输超文本到本地浏览器的传送协议。
- HTTPS（超文本传输安全协议）

### 基于 UDP 协议的

- TFTP（简单文件传输协议）：该协议在熟知端口 69 上使用 UDP 服务。
- SNMP（简单网络管理协议）：使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
- BOOTP（引导程序协议，DHCP 的前身）：应用于无盘设备
- DHCP（动态主机配置协议）：是一个局域网的网络协议
- RIP（路由信息协议）：基于距离矢量算法的路由协议，利用跳数来作为计量标准。
- IGMP（Internet 组管理协议）

### 基于 TCP 和 UDP 协议的

- DNS（域名系统）：DNS 区域传输的时候使用 TCP 协议。域名解析时使用 UDP 协议。DNS 用的是 53 号端口。
- ECHO（回绕协议）

## TCP 和 UDP 之间的区别

TCP：传输控制协议 UDP：用户数据报协议

1. TCP 是面向连接的，UDP 是无连接的即发送数据前不需要先建立链接；
2. TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。
3. TCP 是面向字节流，UDP 面向报文；
4. TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多；
5. TCP 的首部较大为 20 字节，而 UDP 只有 8 字节；

## TCP 的三次握手

https://juejin.cn/post/6844903834708344840

1. 第一次握手：客户端向服务端发送建立连接的请求，里面包含`SYN(Syncchronize Sequence Numbers)`同步序列编号，指明客户端的初始化序列号`ISN`，此时客户端处于`SYN_Send`状态。
2. 第二次握手：服务器收到客户端的`SYN`报文之后，会以自己的`SYN`报文作为应答，并且也是指定了自己的初始化序列号`ISN`，同时会把客户端的`ISN + 1` 作为`ACK` 的值，表示自己已经收到了客户端的`SYN`，此时服务器处于`_SYN_REVD`的状态。
3. 第三次握手：客户端收到`SYN`报文之后，会发送一个`ACK`报文，当然也是一样把服务器的`ISN + 1`作为`ACK`的值，表示已经收到了服务端的 `SYN`报文，此时客户端处于`establised`状态。
4. 服务器收到 ACK 报文之后，也处于`establised`状态，此时双方以建立起了链接。

- 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

- 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。

- 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

- 如果没有第三次握手，就会出现一些丢包的情况，如果只握手 2 次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认 ack 报文丢失，服务端在一段时间内没有收到确认 ack 报文的话就会重新进行第二次握手，也就是服务端会重发 SYN 报文段，客户端收到重发的报文段后会再次给服务端发送确认 ack 报文。

## TCP 的四次挥手

刚开始双方都处于`establised`状态，假如是客户端先发起关闭请求，则：

1、第一次挥手：客户端发送一个`FIN`报文，报文中会指定一个序列号。此时客户端处于`FIN_WAIT1`状态。

2、第二次握手：服务端收到`FIN`之后，会发送`ACK`报文，且把客户端的序列号值 + 1 作为`ACK`报文的序列号值，表明已经收到客户端的报文了，此时服务端处于`CLOSE_WAIT`状态。

3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给`FIN`报文，且指定一个序列号。此时服务端处于`LAST_ACK`的状态。

4、第四次挥手：客户端收到`FIN`之后，一样发送一个`ACK`报文作为应答，且把服务端的序列号值 + 1 作为自己`ACK`报文的序列号值，此时客户端处于`TIME_WAIT`状态。需要过一阵子以确保服务端收到自己的`ACK`报文之后才会进入`CLOSED`状态

5、服务端收到`ACK`报文之后，就处于关闭连接了，处于`CLOSED`状态。

为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。

## HTTP 状态码

1. 1XX 信息性状态码
   - 100 继续
   - 101 切换协议
2. 2XX 成功状态码
   - 200 OK 成功处理了请求
   - 204 No Content 请求处理成功，但没有资源可返回
   - 206 Partial Content 请求资源的某一部分
3. 3XX 重定向状态码
   - 301 永久性重定向，表示请求的资源已被分配了新的 URI，比如启用了新域名、服务器切换到了新机房、网站目录层次重构，这些都算是“永久性”的改变。响应的 Location 首部中应该包含 资源现在所处的 URL
   - 302 临时性重定向，资源的 URL 已临时定位到其他位置，客户端应该使用 Location 首部给出的 URL 来临时定位资源。将来的请求仍应使用老的 URL
   - 303 告诉客户端应该用另一个 URL 获取资源
   - 304 表示自从上一次请求以来页面的内容没有改变，使用缓存数据
4. 4XX 客户端错误状态码
   - 400 表示请求报文中存在语法错误
   - 401 未授权，客户端没有带认证信息或者带了错误的认证信息, 这时客户端可以修改认证信息进行重试
   - 403 服务器拒绝了请求，客户端带了正确的认证信息, 但服务器认为这个认证信息对应的用户是没有对应资源的访问权限的, 因此, 在向管理员获取相关权限之前, 是没有重试的必要的
   - 404 服务器无法找到所请求的 URL
5. 5XX 服务器错误状态码
   - 500 内部服务器错误
   - 502 错误网关
   - 503 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。
   - 504 响应超时

## HTTP1.0 和 HTTP1.1 的区别

**缓存处理**

- 1.0 的 header 中主要是通过 If-Modified-Since（比较资源的最后的更新时间是否一致），expires(资源的过期时间，取决于客户端本地时间)
- 1.1 引入了其他的 If-Match(比较 ETag 是否一致), If-None-Match(比较 ETag 是否不一致), If-Unmodified-Since(比较资源最后的更新时间是否不一致), Entity tag(资源的匹配信息)

**带宽优化**

- 1.0 存在一些浪费带宽的现象，例如客户端只需要某个对象的一部分，但是服务器将整个对象返回。
- 1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content）

**Host 头处理**

- 1.0 中认为每个服务器都有一个唯一的 Ip，因此请求的 url 中并没有传递主机名（hostname）
- 随着虚拟化技术的发展，一台物理机上可以有多个虚拟机，共享同一个 ip，1.1 中的请求消息和响应消息都支持 Host，请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）

**长连接**

- HTTP 是基于 TCP/IP 协议的，创建一个 TCP 连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。
- 1.0 中每次需要使用 keep-alive 参数来告知服务器端要建立一个长连接
- 1.1 默认支持长连接，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点

**新增状态码**
1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表\*\*示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除

**新增请求方式**
1.1 新增 PUT，DELETE，OPTIONS 等

## HTTP 1.x 与 HTTP 2.0 区别

> 参考链接：[HTTP/2 相比 1.0 有哪些重大改进？](https://www.zhihu.com/question/34074946)

1. **header 压缩**
   header 头部带有大量的信息，而且每次使用报头压缩，降低开销，对于相同的 header 数据，不再通过每次请求和响应发送，差量更新 HTTP 头部，既避免了重复 header 的传输，又减小了需要传输的大小
2. **多路复用**
   在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序
3. **二进制分帧**
   消息由一个或多个帧组成。多个帧之间可以乱序发送
4. **服务端推送**
   HTTP2 引入服务器推送，允许服务端推送资源给客户端, 服务器会顺便把一些客户端需要的资源一起推送到客户端

## HTTP 与 HTTPS 的区别

1. HTTP 传输的数据都是未加密的，也就是明文的，HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，比 HTTP 协议的安全性更高。
2. HTTPS 协议需要 CA 证书；
3. 使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443；

## 对称加密和非对称加密的区别

1. 对称加密（symmetrcic encryption）：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES，RC5，3DES 等；例如我们使用 WinRAR 创建一个带密码（口令）的加密压缩包。当你下次要把这个压缩文件解开的时候，你需要输入【同样的】密码。在这个例子中，密码/口令就如同刚才说的“密钥”。
   对称加密主要问题是共享秘钥，除你的计算机（客户端）知道另外一台计算机（服务器）的私钥秘钥，否则无法对通信流进行加密解密。解决这个问题的方案非对称秘钥。

2. 非对称加密：使用两个秘钥：公共秘钥和私有秘钥。私有秘钥由一方密码保存（一般是服务器保存），另一方任何人都可以获得公共秘钥。一般来说指:加密时使用公钥,解密时使用私钥。
   这种密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。

## HTTPS 的单向认证通信过程

非对称加密很耗时，不可能对实际的数据都非对称加密来传输。HTTPS 采用的是处理信息的方式是：结合对称加密+非对称加密这两种方式。用非对称加密的方式来传输对称加密过程中的密钥，采取对称加密的方式来传输数据("握手阶段"的所有通信都是明文的)。

1. 客户端发出 TSL 请求（ClientHello）

   由于客户端(如浏览器)对一些加解密算法的支持程度不一样，但是在 TLS 协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。在 TLS 握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。除此之外，客户端还要产生一个随机数，这个随机数需要保存在客户端，并且传送给服务端，客户端的随机数需要跟服务端产生的随机数结合起来产生后面要讲到的 Master Secret

   > 支持 TLS/SSL 协议版本，比如 TLS 1.0 版
   >
   > 一个客户端生成的随机数 ClientRnd (第 1 个随机数)，稍后用于生成”对话密钥”
   >
   > 支持的加密算法列表，比如 RSA 公钥加密

2. 服务器回应

   服务端在接收到客户端的 Client Hello 之后，服务端需要将自己的证书发送给客户端。这个证书是对于服务端的一种认 证。例如，客户端收到了一个来自于称自己是www.aliyun.com的数据，但是如何证明对方是合法的aliyun呢？这就是证书 的作用，aliyun 的证书可以证明它是 aliyun，而不是其他云。证书是需要申请，并由专门的数字证书认证机构(CA)通过非 常严格的审核之后颁发的电子证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是 附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被串改。另外，证书还有个有效期。

   在服务端向客户端发送的证书中没有提供足够的信息（证书公钥）的时候，还可以向客户端发送一个 Server Key Exchange，此外，对于非常重要的保密数据，服务端还需要对客户端进行验证，以保证数据传送给了安全的合法的客户端。服务端可以向客户端发出 Cerficate Request 消息，要求客户端发送证书对客户端的合法性进行验证。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供 USB 密钥，里面就包含了一张客户端证书。

   跟客户端一样，服务端也需要产生一个随机数发送给客户端。客户端和服务端都需要使用这两个随机数来产生 Master Secret。最后服务端会发送一个 Server Hello Done 消息给客户端，表示 Server Hello 消息结束了。

   > 确认使用的加密通信协议版本，比如 TLS 1.0 版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信
   >
   > 一个服务器生成的随机数 ServerRnd(第 2 个随机数)，稍后用于生成”对话密钥”
   >
   > 确认使用的加密算法，比如 RSA 公钥加密
   >
   > 服务器证书：证书包含服务器信息：域名/服务地址、公钥、证书的 CA

3. 客户端回应（Certificate Verify）

   Client Key Exchange：
   如果服务端需要对客户端进行验证，在客户端收到服务端的 Server Hello 消息之后，首先需要向服务端发送客户端的证书，让服务端来验证客户端的合法性。

   Certificate Verify （验证证书的合法性）：
   接着客户端需要对服务端的证书进行验，颁发证书的机构是否合法、证书中的域名与实际域名不一致、证书已经过期等等。如果客户端是浏览器，若证书受信任则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。

   如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥。然后向服务器发送下面几项项信息：

   > 生成随机数(对称秘钥 PreMasterSecret ，第 3 个随机数): 客户端并使用证书带的公钥将 PreMasterSecret 进行加密. 它是客户端使用一些加密算法(例如：RSA, Diffie-Hellman)产生一个 48 个字节的 Key，这个 Key 叫 PreMaster Secret，很多材料上也被称作 PreMaster Key。
   >
   > 编码改变通知 ChangeCipherSpec: 表示随后的信息都将用双方商定的加密算法和密钥发送
   >
   > ClientHash 值： 通过之前交换的数据(前面发送的所有内容)生成一个 ClientHash 值,用来供服务器校验。
   >
   > 客户端握手结束通知，表示客户端的握手阶段已经结束。

   此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数 ClientRnd 和 ServerRnd 与自己计算产生的 PreMasterSecret ，计算得到协商密钥;
   `enc_key（SessionSecret）=Fuc(ClientRnd, ServerRnd, PreMasterSecret )`

4. 服务器的最后回应（Server Finish）

   4.1. 使用自己证书的私钥解密出 PreMasterSecret

   4.2. 生成 SessionSecret：服务端根据之前的随机数（ClientRnd ，ServerRnd，PreMasterSecret ）和约定的加密算法，生成用于加密后续传输数据的会话密钥 SessionSecret。

   `enc_key=Fuc(ClientRnd, ServerRnd, PreMasterSecret )`

   4.3.校验 clientHash (确认不是假的客户端）和密钥 SessionSecret 正确性：
   计算之前所有接收信息的 hash 值，即为 serverHash。然后解密客户端发送 encrypted_handshake_message 的 ClientHash，验证数据和密钥正确性（即 serverHash ==ClientHash 是否为 true）；

   4.4. Change Cipher Spec 确认变更编码: 会给客户端发送一个 ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret 加密数据了。

   4.5. Encrypted Handshake Message Finish 信息：服务器也结合所有当前的通信参数信息生成一段 Finish 消息数据，并采用协商密钥 SessionSecret 与算法加密并发送到客户端， 以验证之前通过握手建立起来的加解密通道是否成功。

5. 握手结束
   客户端计算所有接收信息的 hash 值，并采用协商密钥解密 encrypted_handshake_message，验证服务器发送的数据和密钥，验证通过则握手完成;

总结

- 客户端（告知服务端支持的加密配置）
  1. 客户端支持的加密协议版本；
  2. 客户端支持的加密套件；
  3. 第一个客户端随机数 clientRnd;
- 服务端（协商需要使用的加密配置，可能需要验证客户端合法性）
  1. 服务端选用的加密套件和加密协议版本；
  2. 服务端的证书（服务器域名、公钥、证书颁发机构等信息）；
  3. 服务端随机数 serverRnd;
- 客户端（证书验证，生成对称秘钥后私钥加密，生成会话秘钥）
  1. 校验服务端的证书信息；
  2. 生成第三个随机数 preMasterSecret，并使用证书中的公钥进行非对称加密，生成会话密钥
  3. 通信的数据生成客户端哈希值 clientHash；
- 服务端(私钥解密得到对称秘钥，生成会话秘钥，验证客户端的内容 hash)
  1. 使用私钥对 preMasterSecret 进行非对称解密，生成会话密钥
  2. 服务端使用通信数据生成一个服务端哈希值 serverHash，用于校验客户端的 clientHash；

> 参考[HTTP 详解(1)-工作原理](https://guisu.blog.csdn.net/article/details/8680808)

## WebSocket 协议

> 参考链接：[HTML5 WebSocket](https://www.runoob.com/html/html5-websocket.html)

WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。

WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每 1 秒），由浏览器对服务器发出 HTTP 请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而 HTTP 请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。

![websocket和ajax轮询的对比图](../images/websocket.png)

应用场景:实现即时通讯:如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询
