<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [哪些情况会导致内存泄漏](#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F)
- [new 运算符的过程](#new-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%BF%87%E7%A8%8B)
- [什么是 JavaScript 中的包装类型？](#%E4%BB%80%E4%B9%88%E6%98%AF-javascript-%E4%B8%AD%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B)
- [escape、encodeURI、encodeURIComponent 的区别](#escapeencodeuriencodeuricomponent-%E7%9A%84%E5%8C%BA%E5%88%AB)
- [重绘和重排](#%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92)
- [对象创建的方式有哪些？](#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B)
- [函数的创建方式](#%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F)
- [变量提升](#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87)
- [["1", "2", "3"].map(parseInt) 输出什么？](#1-2-3mapparseint-%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 哪些情况会导致内存泄漏

(1) 意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局
变量，而使这个变量一直留在内存中无法被回收。

(2) 被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记
取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被
一直留在内存中，而无法被回收。

(3) 游离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删
除，由于一直保留了对这个元素的引用，所以它也无法被回收。

(4) 闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。

## new 运算符的过程

1. 创建一个空对象{}；
2. 构造函数中的 this 指向该空对象
3. 执行构造函数为这个空对象添加属性
4. 判断构造函数有没有返回值，如果返回值是个对象，则返回这个对象；否则返回创建的“空对象”

## 什么是 JavaScript 中的包装类型？

在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操
作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在
后台隐式地将基本类型的值转换为对象。

基本类型转换为对象的过程，称为包装类型（Wrapper）。

基本类型转换成对象

```js
const str = "abc";
str.length; // 3
str.toUpperCase(); // ABC
```

在访问'abc'.length 时, JavaScript 将'abc'在后台转换成 String('abc')，然后再访问其 length 属性。
JavaScript 也可以使用 `Object` 函数显式地将基本类型转换为包装类

```js
const str = "abc";
Object(str); // String {0: "a", 1: "b", 2: "c", length: 3, ...}
```

也可以使用 `valueOf` 方法将包装类型倒转成基本类型

```js
const str = "abc";
const b = Object(str); // String {0: "a", 1: "b", 2: "c", length: 3, ...}
const c = b.valueOf(b); // 'abc'
```

## escape、encodeURI、encodeURIComponent 的区别

encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合
法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。

encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊
字符也会得到转义。

escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为
0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode
编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，
再在每个字节前加上%

## 对象创建的方式有哪些？

一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大
量相似对象的时候，会产生大量的重复代码。但 js 和一般的面向对
象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来
进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：

（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装
创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一
个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是
简单的封装了复用代码，而没有建立起对象和类型间的关系。

（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，
只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。
执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数
的 prototype 属性，然后将执行上下文中的 this 指向这个对象，
最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因
为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。
构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建
立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存
在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函
数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次
都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有
的实例都可以通用的。

（3）第三种模式是原型模式，因为每一个函数都有一个 prototype
属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例
都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方
法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决
了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有
办法通过传入参数来初始化值，另一个是如果存在一个引用类型如
Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用
类型值的改变会影响所有的实例。

（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自
定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存
在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化
对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的
解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使
用了两种不同的模式，所以对于代码的封装性不够好。

（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创
建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以
实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式
很好地对上面的混合模式进行了封装。

（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实
现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，
在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函
数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法
实现对象的识别。

## 函数的创建方式

1. 函数声明
   ```javascript
   function fn = (a,b) {}
   ```
2. 函数表达式，字面量的形式
   ```javascript
   const add = function (a, b) {};
   ```
3. 构造函数 Function
   `javascript
	const add = new Function(){}
	`
   函数申明与表达式的区别：解析器会先读取函数声明，并使其在执行任何代码之前可以访问；而函数表达式则必须等到解析器执行到它所在的代码行才会真正被解释执行。

new Function 的区别：不推荐用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规 ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。

## 变量提升

以下代码将如何打印

```javascript
fn();
console.log(a); // undefined
var a = 1;
console.log(typeof a); // number
console.log(typeof b); // undefined
var b = 1;
function fn() {
  var c = (d = 1);
}
console.log(d); // 1,全局变量d = 1
console.log(c); // ReferenceError: c is not defined
```

## ["1", "2", "3"].map(parseInt) 输出什么？

> parseInt(string, radix) 解析一个字符串并返回指定基数的十进制整数， radix 是 2-36 之间的整数，表示被解析字符串的基数

parseInt 方法接收两个参数(string, radix)，map 遍历函数包含三个参数，parseInt 会把第三个参数忽略。
map 遍历过程中 parseInt 方法将会通过以下方式被调用：
parseInt("1", 0) // 0 默认是以十进制解析字符 1 => 1
parseInt("2", 1) // 基数 1 不属于 2-36 之间的整数 => NAN
parseInt("3", 2) // 以 2 进制解析字符 3(二进制只识别 0 和 1) => NAN
结果：[1, NAN,NAN]
