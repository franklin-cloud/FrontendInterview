<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [谈谈对前端工程化的理解](#%E8%B0%88%E8%B0%88%E5%AF%B9%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3)
  - [模块化](#%E6%A8%A1%E5%9D%97%E5%8C%96)
  - [组件化](#%E7%BB%84%E4%BB%B6%E5%8C%96)
  - [规范化](#%E8%A7%84%E8%8C%83%E5%8C%96)
  - [自动化](#%E8%87%AA%E5%8A%A8%E5%8C%96)
- [js 的几种模块规范](#js-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83)
- [ES6 模块与 CommonJS 模块、AMD、CMD 的差异](#es6-%E6%A8%A1%E5%9D%97%E4%B8%8E-commonjs-%E6%A8%A1%E5%9D%97amdcmd-%E7%9A%84%E5%B7%AE%E5%BC%82)
  - [CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。](#commonjs-%E6%A8%A1%E5%9D%97%E8%BE%93%E5%87%BA%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E5%80%BC%E7%9A%84%E6%8B%B7%E8%B4%9Des6-%E6%A8%A1%E5%9D%97%E8%BE%93%E5%87%BA%E7%9A%84%E6%98%AF%E5%80%BC%E7%9A%84%E5%BC%95%E7%94%A8)
  - [JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值](#js-%E5%BC%95%E6%93%8E%E5%AF%B9%E8%84%9A%E6%9C%AC%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%91%BD%E4%BB%A4-import%E5%B0%B1%E4%BC%9A%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%AF%BB%E5%BC%95%E7%94%A8%E7%AD%89%E5%88%B0%E8%84%9A%E6%9C%AC%E7%9C%9F%E6%AD%A3%E6%89%A7%E8%A1%8C%E6%97%B6%E5%86%8D%E6%A0%B9%E6%8D%AE%E8%BF%99%E4%B8%AA%E5%8F%AA%E8%AF%BB%E5%BC%95%E7%94%A8%E5%88%B0%E8%A2%AB%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%82%A3%E4%B8%AA%E6%A8%A1%E5%9D%97%E9%87%8C%E9%9D%A2%E5%8E%BB%E5%8F%96%E5%80%BC)
  - [CommonJS 模块是运行时加载，ES6 模块是编译时输出接口](#commonjs-%E6%A8%A1%E5%9D%97%E6%98%AF%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A0%E8%BD%BDes6-%E6%A8%A1%E5%9D%97%E6%98%AF%E7%BC%96%E8%AF%91%E6%97%B6%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3)
  - [CommonJS 模块的 require()是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段](#commonjs-%E6%A8%A1%E5%9D%97%E7%9A%84-require%E6%98%AF%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97es6-%E6%A8%A1%E5%9D%97%E7%9A%84-import-%E5%91%BD%E4%BB%A4%E6%98%AF%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E6%9E%90%E9%98%B6%E6%AE%B5)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 谈谈对前端工程化的理解

> 前端工程化里的工程是一个很大的概念，甚至创建一个 git 仓库，也可以理解为创建了一个工程，软件工程的定义是运用计算机科学的理论和技术，以及工程管理的原则和方法，按进度和预算，实现满足用户要求的软件产品的定义，开发和维护的工程以及研究的学科。

**前端工程化是为了让前端可以自成体系，具体可以从四方面去讨论，模块化，组件化，规范化和自动化。**

### 模块化

> 模块化：将大的文件拆分成互相依赖的小文件，再进行统一的拼装和加载。
>
> js 的模块化：利用 webpack+babel 的模式将所有模块系统进行打包，同步加载，也可以搭乘多个 chunk 异步加载。
>
> css 模块化：之前的 sass less 等预处理器虽然实现了 css 的拆分，但是并没有解决模块化很重要的一个问题，即选择器的全局污染问题。有三种解决办法，第一种是利用 webcomponents 的技术实现，这个技术虽然解决了全局污染问题，但是由于兼容性问题，目前用的不多，第二种是 css in js 将 css 的技术全部摒，利用 js 或者 json 格式去加载 css，这种方式简单粗暴，并且不容易处理伪类选择器的问题，被大众所认可的是第三种解决方案，即 css modules ，所有的 css 文件由 js 来管理，这种技术最大程度利用了 css 的生态和模块化的原则，其中 vue 中的 scoped 就是这种技术的提现。利用浏览器的 script 标签，type 类型选 modules 类型即可。
>
> 资源的模块化：webpack 的成功不仅仅是因为将 js 系统进行模块化处理，而是它的模块化原理，即任何资源都可以模块
> 化且应该模块化处理，优点有以下三点，1：目录结构清晰化，2：资源处理集成化，3：项目依赖单一化。

### 组件化

> 组件化：将 UI 页面拆分正有模板+样式+逻辑组成的功能单元，称为组件，组件化不等于模块化，模块化是在资源和代码方面对文件的拆分，而组件化是在 UI 层面进行的拆分。传统前端框架的思想是以 dom 优先，先操作 dom，再写出可复用的逻辑单元来操作 dom，而组件化框架是组件优先，将 dom 和与之一起的逻辑组成一个组件，再进行引用。我们封装了组件后，还需要对组件间的关系进行判定，例如继承，扩展，嵌套，包含等，这些关系统称为依赖

### 规范化

> 规范化：规范化是前端工程化很重要的一部分，项目前期规范制定的好坏，直接决定后期的开发质量，分为项目目录规范化，编码规范化，前后端接口规范化，git 分支管理，commit 描述规范，组件管理等编码规范化分为 htmlcss js img 命名规范这几类 接口规范，目的是规则先行，以减少联调中不必要的问题和麻烦，自责划分 前端，渲染逻辑和交互逻辑，后台，处理业务逻辑，各种格式的规定，例如 json 尽量简洁轻量，日期尽量字符串，等等。

### 自动化

> 自动化：让简单重复的工作交给机器完成，例如自动化测试，自动化部署，自动化构建，持续继承等。

## js 的几种模块规范

```js
js 中现在比较成熟的有四种模块加载方案。

第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是
服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式
加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。

第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定
义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。

第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js
的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。

第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。
```

## ES6 模块与 CommonJS 模块、AMD、CMD 的差异

> CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。
>
> CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

### CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值

```js
// A.js
var num = 1;
function incCounter() {
  num++;
}
module.exports = {
  counter: num,
  incCounter: incCounter,
};
// main.js
var mod = require("./A");

console.log(mod.counter); // 1
mod.incCounter();
console.log(mod.counter); // 1
```

### JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值

```js
// A.js
export let num = 1;
export function incCounter() {
  num++;
}

// main.js
import { num, incCounter } from "./A";
console.log(num); // 1
incCounter();
console.log(num); // 2
```

### CommonJS 模块是运行时加载，ES6 模块是编译时输出接口

### CommonJS 模块的 require()是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段
