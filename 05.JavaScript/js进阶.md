<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [对作用域、作用域链的理解](#%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3)
- [对 this 对象的理解](#%E5%AF%B9-this-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3)
- [对象创建的方式有哪些？](#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B)
- [哪些情况会导致内存泄漏](#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F)
- [JavaScript 继承的几种实现方式](#javascript-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F)
- [eval 是做什么的](#eval-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84)
- [Object.defineProperty 用法](#objectdefineproperty-%E7%94%A8%E6%B3%95)
- [JS 跨域怎么解决](#js-%E8%B7%A8%E5%9F%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3)
- [JSONP 怎么实现的](#jsonp-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84)
- [JOSNP 有什么优缺点](#josnp-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9)
- [new 运算符的过程](#new-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%BF%87%E7%A8%8B)
- [什么是 JavaScript 中的包装类型？](#%E4%BB%80%E4%B9%88%E6%98%AF-javascript-%E4%B8%AD%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B)
- [对 JSON 的理解](#%E5%AF%B9-json-%E7%9A%84%E7%90%86%E8%A7%A3)
- [JavaScript 脚本延迟加载的方式有哪些？](#javascript-%E8%84%9A%E6%9C%AC%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B)
- [js 脚本 defer 和 async 的区别](#js-%E8%84%9A%E6%9C%AC-defer-%E5%92%8C-async-%E7%9A%84%E5%8C%BA%E5%88%AB)
- [什么是 DOM 和 BOM？](#%E4%BB%80%E4%B9%88%E6%98%AF-dom-%E5%92%8C-bom)
- [escape、encodeURI、encodeURIComponent 的区别](#escapeencodeuriencodeuricomponent-%E7%9A%84%E5%8C%BA%E5%88%AB)
- [什么是尾调用，使用尾调用有什么好处？](#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BD%BF%E7%94%A8%E5%B0%BE%E8%B0%83%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84)
- [ajax、axios、fetch 的区别](#ajaxaxiosfetch-%E7%9A%84%E5%8C%BA%E5%88%AB)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 对作用域、作用域链的理解

**作用域**

- 全局作用域和函数作用域

1. 全局作用域: 最外层函数和最外层函数外面定义的变量拥有全局作用域
   所有未定义直接赋值的变量自动声明为全局作用域
   所有 window 对象的属性拥有全局作用域
   全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空
   间，容易引起命名冲突。

2. 函数作用域：函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到作用域是分层的，内层作用域可以访问外层作用域，反之不行。

- 块级作用域
  使用 ES6 中新增的 let 和 const 指令可以声明块级作用域，块级作用
  域可以在函数中创建也可以在一个代码块中的创建（由`{ }`包裹的代
  码片段）
  let 和 const 声明的变量不会有变量提升，也不可以重复声明
  在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量
  限制在循环内部。

**作用域链**

在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个
变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域
查找，依次向上级作用域查找，直到访问到 window 对象就被终止，
这一层层的关系就是作用域链。

作用域链的作用是保证对执行环境有权访问的所有变量和函数的有
序访问，通过作用域链，可以访问到外层环境的变量和函数。
作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个
包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是
当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全
局对象）始终是作用域链的最后一个对象。
当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域
链向后查找

## 对 this 对象的理解

this 是执行上下文中的一个属性，它指向最后一次调用这个方法的
对象。

在实际开发中，this 的指向可以通过四种调用模式来判断。

第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作
为函数来调用时，this 指向全局对象。

第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，
this 指向这个对象。

第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行
前会新创建一个对象，this 指向这个新创建的对象。

第四种是 apply、call、bind 调用模式，这三个方法都可以显
示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：
一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，
第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。
也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举
出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对
象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其
他情况下都不会改变。

这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call
和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。

## 对象创建的方式有哪些？

一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大
量相似对象的时候，会产生大量的重复代码。但 js 和一般的面向对
象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来
进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：

（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装
创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一
个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是
简单的封装了复用代码，而没有建立起对象和类型间的关系。

（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，
只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。
执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数
的 prototype 属性，然后将执行上下文中的 this 指向这个对象，
最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因
为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。
构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建
立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存
在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函
数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次
都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有
的实例都可以通用的。

（3）第三种模式是原型模式，因为每一个函数都有一个 prototype
属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例
都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方
法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决
了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有
办法通过传入参数来初始化值，另一个是如果存在一个引用类型如
Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用
类型值的改变会影响所有的实例。

（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自
定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存
在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化
对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的
解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使
用了两种不同的模式，所以对于代码的封装性不够好。

（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创
建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以
实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式
很好地对上面的混合模式进行了封装。

（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实
现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，
在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函
数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法
实现对象的识别。

## 哪些情况会导致内存泄漏

(1) 意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局
变量，而使这个变量一直留在内存中无法被回收。

(2) 被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记
取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被
一直留在内存中，而无法被回收。

(3) 脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删
除，由于一直保留了对这个元素的引用，所以它也无法被回收。

(4) 闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。

## JavaScript 继承的几种实现方式

- 第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。

- 第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。

- 第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。

- 第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。

- 第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。

- 第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

## eval 是做什么的

```js
它的功能是把对应的字符串解析成 JS 代码并运行。

应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。
```

## Object.defineProperty 用法

```js
Object.defineProperty(target, property, descriptor);
```

- target
  要定义属性的目标对象。
- property
  要定义或修改的属性的名称或 Symbol 。
- descriptor
  要定义或修改的属性描述符。参数有：
  - value
    该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。
    默认为 undefined。
  - writable
    当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。
    默认为 false。
  - configurable
    当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。
    默认为 false。
  - enumerable
    当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。
    默认为 false。

```js
async function bar() {
  return "lee";
}

console.log(bar()); // Promise {<resolved>: "lee"}
```

- async await 搭配使用的时候，await 是等待此函数执行后，再执行下一个，可以把异步函数变成同步来执行，控制函数的执行顺序。await 一定要搭配 async 使用。

> 当 await 后的函数是返回的 promise。

```js
let foo = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("lee");
      resolve();
    }, 1000);
  });
};

async function bar() {
  await foo();
  console.log("van");
}
console.log(bar()); // 隔1秒同时输出 lee van
```

> 当 await 后跟的是普通函数（非 promise()）

```js
let f1 = () => {
  setTimeout(() => {
    console.log("lee");
  }, 1000);
};

let f2 = () => {
  setTimeout(() => {
    console.log("van");
  }, 1000);
};

async function bar() {
  await f1();
  await f2();
  console.log("yeah");
}

console.log(bar()); // yeah 隔1秒同时输出 lee fan
```

## JS 跨域怎么解决

> 什么是跨域？当一个请求 url 的 协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域。
>
> 参考链接:[前端常见跨域解决方案（全）](https://segmentfault.com/a/1190000011145364)

1. JSONP (JSON with Padding)
   通过动态创建 script，再请求一个带参网址实现跨域通信。
   > 参考链接：[jsonp 的原理与实现](https://segmentfault.com/a/1190000007665361#articleHeader1)
2. CORS (跨域资源共享)
   CORS 的基本思想就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。

   普通跨域请求：只需服务端设置 `Access-Control-Allow-Origin` 即可，前端无须设置，若要带 cookie 请求：前后端都需要设置。前端设置`withCredentials`为 true,后端设置`Access-Control-Allow-Credentials`为 true,同时`Access-Control-Allow-Origin`不能设置为`*`

   目前，所有浏览器都支持该功能(IE8+；IE8/9 需要使用 XDomainRequest 对象来支持 CORS)，CORS 也已经成为主流的跨域解决方案。

3. window.postMessage
   现代浏览器中多窗口通信使用 HTML5 规范的 targetWindow.postMessage(data, origin);其中 data 是需要发送的对象，origin 是目标窗口的 origin。window.addEventListener('message', handler, false);handler 的 event.data 是 postMessage 发送来的数据，event.origin 是发送窗口的 origin，event.source 是发送消息的窗口引用
4. 服务器代理
   内部服务器代理请求跨域 url，然后返回数据

## JSONP 怎么实现的

> JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。

举个例子来说明具体情况：

前端代码

```js
<script>
function test(data) {
    console.log(data.name);
}
</script>
<script src="http://127.0.0.1:8088/jsonp?callback=test"></script>
```

后端代码

```js
res.end('test({"name": "Monkey"})');
```

以上就实现了 JSONP 跨域，前端正常打印出了"Monkey"

请求 JSONP 之前就定义好回调函数 test，后端返回的是调用 test 函数的 js 代码，浏览器加载这段代码后立即执行

## JOSNP 有什么优缺点

缺点：

1. 它只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求
2. 它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题。
3. JSONP 在调用失败的时候不会返回各种 HTTP 状态码。
4. 安全性。假如提供 JSONP 的服务存在页面注入漏洞，即它返回的 JavaScript 的内容被人控制的。那么结果是什么？所有调用这个 JSONP 的网站都会存在漏洞。于是无法把危险控制在一个域名下…所以在使用 JSONP 的时候必须要保证使用的 JSONP 服务必须是安全可信的。

优点：

1. 它不像 XMLHttpRequest 对象实现的 Ajax 请求那样受到同源策略的限制，JSONP 可以跨越同源策略；
2. 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支持
3. 在请求完毕后可以通过调用 callback 的方式回传结果。

## new 运算符的过程

1. 创建一个空对象{}；
2. 构造函数中的 this 指向该空对象
3. 执行构造函数为这个空对象添加属性
4. 判断构造函数有没有返回值，如果返回值是个对象，则返回这个对象；否则返回创建的“空对象”

## 什么是 JavaScript 中的包装类型？

在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操
作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在
后台隐式地将基本类型的值转换为对象。

基本类型转换为对象的过程，称为包装类型（Wrapper）。

基本类型转换成对象

```js
const str = "abc";
str.length; // 3
str.toUpperCase(); // ABC
```

在访问'abc'.length 时, JavaScript 将'abc'在后台转换成 String('abc')，然后再访问其 length 属性。
JavaScript 也可以使用 `Object` 函数显式地将基本类型转换为包装类

```js
const str = "abc";
Object(str); // String {0: "a", 1: "b", 2: "c", length: 3, ...}
```

也可以使用 `valueOf` 方法将包装类型倒转成基本类型

```js
const str = "abc";
const b = Object(str); // String {0: "a", 1: "b", 2: "c", length: 3, ...}
const c = b.valueOf(b); // 'abc'
```

## 对 JSON 的理解

JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编
程语言读取和作为数据格式来传递。

- JSON.stringify 函数
  通过传入一个符合 JSON 格式的数据结构，
  将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格
  式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合
  规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化
  为 JSON 格式的字符串

  ```js
  JSON.stringify(value,replacer, space)
  value:
  必需， 要转换的 JavaScript 值（通常为对象或数组）。

  replacer:
  可选。用于转换结果的函数或数组。

  如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：""。

  如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。

  space:
  可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\t。
  ```

- JSON.parse() 函数
  这个函数用来将 JSON 格式的字符串转换为一
  个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串
  的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以
  通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访
  问

## JavaScript 脚本延迟加载的方式有哪些？

延迟加载就是等页面加载完成之后再加载 JavaScript 文件。js 延
迟加载有助于提高页面加载速度。

一般有以下几种方式：

1. defer 属性：给 js 脚本添加 defer 属性，这个属性会让脚本的加
   载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文
   件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性
   的脚本按规范来说最后是**顺序执行**的，但是在一些浏览器中可能不是
   这样。
2. async 属性：给 js 脚本添加 async 属性，这个属性会使脚本异步
   加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js
   脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async
   属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次
   执行。
3. 动态创建 DOM 方式：动态创建 DOM 标签的方式，可以对文档的加载
   事件进行监听，当文档加载完成后再动态的创建 script 标签来引入
   js 脚本。
4. 使用 setTimeout 延迟方法：设置一个定时器来延迟加载 js 脚本文
   件
5. 让 JS 最后加载：将 js 脚本放在文档的底部，来使 js 脚本尽可能
   的在最后来加载执行。

## js 脚本 defer 和 async 的区别

- defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。

- async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。
- ## async await

> 官网：async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。

- async 单独使用的时候，放在函数前面表示这个函数是一个异步函数，如果 async 函数有返回结果，必须要用.then()方法来承接（也就是返回的值会被自动处理成 promise 对象）

## 什么是 DOM 和 BOM？

DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象
主要定义了处理网页内容的方法和接口。
BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，
这个对象主要定义了与浏览器进行交互的法和接口。BOM 的核心是
window，而 window 对象具有双重角色，它既是通过 js 访问浏览器
窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页
中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方
法存在。window 对象含有 location 对象、navigator 对象、screen
对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM
的 window 对象的子对象。

## escape、encodeURI、encodeURIComponent 的区别

encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合
法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。
encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊
字符也会得到转义。
escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为
0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode
编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，
再在每个字节前加上%

## 什么是尾调用，使用尾调用有什么好处？

尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行
栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上
下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，
因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上
下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优
化只在严格模式下开启，正常模式是无效的。

## ajax、axios、fetch 的区别

AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在
后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。

Fetch 是在 ES6 出现的，使用了 ES6 中的 promise 对象。Fetch 是基于 promise 设计的，fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象。

fetch 只对网络请求报错，对 400，500 都当做成功的请求，服务器
返回 400，500 错误码时并不会 reject，只有网络错误这些导致请
求不能完成时，fetch 才会被 reject。

fetch 没有办法原生监测请求的进度，而 XHR 可以

Axios 是一种基于 Promise 封装的 HTTP 客户端
